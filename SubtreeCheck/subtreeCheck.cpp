#include<iostream>
#include<string>
using namespace std;
struct node
{
    int data;
    node *left, *right;
};

node *getNewNode(int d)
{
    node *n = new node;
    n->left = NULL;n->right = NULL;n->data = d;
    return n;
}
void preorder(node *root, string &s)
{
    if (root)
    {
        s.append(to_string(root->data));
        preorder(root->left, s);
        preorder(root->right, s);
    }
}
void inorder(node *root, string &s){
    if(root){
        inorder(root->left,s);
        s.append(to_string(root->data));
        inorder(root->right, s);
    }
}
int checkSubtree(node *root1, node *root2){
    string inorder1,inorder2,preorder1,preorder2;
    inorder(root2,inorder2);preorder(root2,preorder2);
    inorder(root1,inorder1);preorder(root1,preorder1);
    cout<<inorder2<<endl<<inorder1<<endl;
    cout<<preorder2<<endl<<preorder1<<endl;
    if(inorder2.find(inorder1) != -1 && preorder2.find(preorder1) != -1){
        return 1;
    }
    return 0;
}
int main()
{/*
    A unique tree is constructed by inorder and preporder/postorder
    We find inorder and preorder for both trees
    We will check the string generated by inorder and preorder travsersals
    of small tree is substring of inorder and preorder traversals of parent tree
*/

// Tree Construction
// Big Tree
    node *root2 = getNewNode(8);
    root2->left = getNewNode(10);
    root2->right = getNewNode(9);
    root2->left->left = getNewNode(7);
    root2->left->right = getNewNode(8);
    root2->right->right = getNewNode(2);
    root2->right->left = getNewNode(1);
// Small Tree
    node *root1 = getNewNode(9);
    root1->left = getNewNode(1);
    root1->right = getNewNode(2);
    if(checkSubtree(root1,root2)){ 
        cout<<"Yes"<<endl;
    }else{
        cout<<"No"<<endl;
    }
    return 0;
}